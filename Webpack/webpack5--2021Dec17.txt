Udemy: Webpack 5: The complete guide for beginners
Github: https://github.com/vp-online-courses/webpack-tutorial


OTHERS:
* Handlebars: Templating engine for js. If you want to generate html inside js, then these can help you in creating html page
* EsLint: Can be installed/run separate from webpack. It uses a config file, generally named `.eslintrc` and added in root folder. The config file has a json object for config. If you use advanced properties, then install `babel-parser`, and use that as the parser for eslint, else eslint may complain about use of advanced features not part of ecmascript spec



NPM
* npm init -- to make package.json
* In package.json, you can define a "scripts" key with object-type value (just like as there is "dependencies" and "devDependencies" section in package.json). In the object type value for "scripts", add a command name as key (like "test", "start", "start:dev", etc.) and as value give a string with multiple commands concatenated. This creates an alias so that instead of running the whole big command, you just do "npm run test", or "npm run start:dev"



WEBPACK
* `webpack` and `webpack-cli` installed as devDependency (using --save-dev) in package.json. `webpack` is the actual package, and `webpack-cli` allows running webpack from the command line.

* Use `npm webpack` to run webpack. 
--|---- When webpack runs, it creates a `dist` folder and a `main.js` with bundled javascript in it - after properly resolving all dependencies. (Side-note: These names are configurable for webpack.) 
--|---- **IMPORTANT**: Use 1npm webpack --config {custom-file-name}1 to provide a custom webpack config js file name. This can be used alongwith making custom npm scripts to pass different config file for dev vs production build.
--|---- Use `npm webpack --stats detailed` to get a detailed layout of how webpack is bundling different files.
--|---- **IMPORTANT** Remember to have your webpages reference the bundled js file generated by webpack, rather than use the js file in source code

* Webpack stores configuration in a "js" file, typically named `webpack.config.js`. 
--|---- The webpack config js file should export out the webpack config object. At least as of Webpack-5, since webpack is run by Node, so `webpack.config.js` is written in a form accepted by node, i.e., in CommonJS. That's why it has `module.exports = {...}` line rather than ECMAScript import syntax, but looking at webpack docs, it seems to be using ECMAScript style of import and export.. so maybe that has changed! (Refr: https://www.tutorialsteacher.com/nodejs/nodejs-module-exports ; https://nodejs.org/api/modules.html#moduleexports). 
--|---- For values that can be in configuration, see https://webpack.js.org/concepts/configuration/

* PublicPath: https://webpack.js.org/guides/public-path/ ; Publicpath allows configuring base-path for all "assets" in your application. Recall how publicPath can also be configured on the fly, as mentioned in the docs. Also, that setting of publicPath is the first thing that should be done on client side application

* A good practice is to append md5 hash of file contents to file name.. The goal here is that when you change the file contents.. the md5 hash will change, causing the browser to refetch the new file (with modifications) rather than reusing the old, cached file. This is particularly useful for css filenames, but not sure how to do so for js filename, specially the js filename used in index-html file

* **VERY VERY IMPORTANT**: See section on `entry` config for webpack (https://webpack.js.org/configuration/entry-context/) -- Entry can be a json object and this is useful for having multipage js rather than 1 single js bundle. 
--|---- In `output >> filename` config, and also in MiniCssExtractPlugin for output css filename, if you use `[name]` placeholder (with square brackets), then it will give a human readable name to bundled js/css.. just like using `[contenthash]` appends contenthash in name. **HOWEVER**, by default, the generate js and css will be included in same html file
--|---- When doing multipage build - also - call the `HtmlWebpackPlugin` multiple times, giving it different `chunk` values in configuration. This will end up creating multiple html files.
--|---- See `optimization >> splitChunks >> chunks: 'all'` to chunk the bundled js. The count of bundled-js files can be multiple for multi-page application. All are further chunked and common dependencies are extracted. Additionally, using this feature, you can also chunk out async called js components into a separate js file - which can be the case if you have a single page application with multiple features. Doing so reduces the load time for main js file, and loads necessary chunks only when needed - as triggered by user interaction.
--|----|---- A good place to understand about splitChunks.cacheGroups: https://gist.github.com/sokra/1522d586b8e5c0f5072d7565c2bee693#cache-groups
--|---- **IMPORTANT**: If making a react application, using react-router, that is served by Node server.. note that the user may give as first url, a path to specific feature module on page. If you do a chunk on async module import, then this will cause one more import to occur immediately.. not that it's bad.. but just something to be aware of..

* Asset modules: added in Webpack-5; allows using asset files in js code without adding any external dependency. See https://webpack.js.org/guides/asset-modules/
--|---- For bundling: Images / fonts / plain-text file in js files
--|---- The "test" property of a configuration takes a regex. Make sure it is proper.. like adding a "$" sign after extension to make sure the correct file is picked up. If needed, add "exclude" property.
--|---- It is possible to configure the name and location of the file as they get emitted by webpack in output folder (see webpack docs)
--|---- 4 types of asset modules:
--|----|---- asset/resource: These contain large images or font-files. Webpack will output them in folder, and add a link to it in the bundled js file
--|----|---- asset/inline: These are small svg images. Webpack will inline them in the js file as data uri, so there won't be any new files corresponding to these resources in the output folder
--|----|---- asset: Generic asset module that treats a file as inline if its size is less than 8KB, or as a resource if its size is more than 8KB. The 8KB threshold is configurable.
--|----|---- asset/source: if you want to import the text string in a file as is.. and put in js code. For example, maybe translations, error text, etc.

* Loaders - to load css, sass, other javascript files, handlebars, xml, etc. - everything apart from images / fonts / plain text covered in asset modules
--|---- **IMPORTANT**: Webpack includes asset modules so they do not need to be "npm installed" separately. However, loaders need to be installed separately before webpack can use it. Install it with --save-dev
--|---- **IMPORTANT**: Pay attention to order of loaders in configuration.. webpack will run the last loader in the list first, i.e. it goes right to left, or bottom to top, and not the usual way..!
--|---- For loaders, ("test", "use") is included in webpack config's modules >> rules, rather than having ("test", "type") as done for asset modules
--|---- css-loader and style-loader are 2 loaders for reading css and incorporating it in code (Yes.. both are needed). From code shown in the Udemy course, it seems the styles are pulled in head/style tag!

* Plugins - to do something that loaders cannot do in itself.. like defining global vars, minify, uglify, generate multiple files than just 1 bundle.js, etc.
--|---- Webpack plugin list (not exhaustive): https://webpack.js.org/configuration/plugins/
--|---- Shown plugins in course: TerserPlugin (to reduce js size; removes the need for separate minify + uglify); MiniCssExtractPlugin (pull css in separate stylesheet rather than have embedded in head/script; CleanWebpackPlugin (to clean dist folder and also possible to clean any other folders); HtmlWebpackPlugin (IMPORTANT -- this is to wire in the name of generated js and css filename **with content hash** in the html. Do note that the generated html contains both script and style in head.. so best to use a custom template so that script is added in body, not in head - but considering that this html file has an empty body, not sure if that matters!)

* mode - can be 'none', or 'production' or 'development'
--|---- See https://webpack.js.org/configuration/mode/#root   - Setting development vs production mode also sets some variables that can be used in code and loads some plugins. Development mode keeps the sourcemap so if any error happens, it can be seen where that's happening in code, but not in production mode.

* webpack-dev-server
--|---- Add `devServer` key in webpack config, having a json value which configures dev server. See https://webpack.js.org/configuration/dev-server/
--|---- Use `webpack serve` rather than `webpack` to bundle and then start the webpack dev server. Also add `--hot` to enable hot module replacement

* After you install Node on your system, `express` library can be used to develop application that run in node server. See https://www.digitalocean.com/community/tutorials/nodejs-express-basics
--|---- Some js libraries can be in-built inside node itself.. like, `path`, so it can be imported in server-js file, but doesn't need to be installed to project (Or, if your typescript compiler complains, just add it as save-dev). On other hand, certain dependencies aren't in Node, like, `express`. So, in order to use it in server-js file, it'll need to be installed.

* Module Federation:
--|---- https://webpack.js.org/plugins/module-federation-plugin/
--|---- An application can both import remote resources, and then export resources from itself
--|---- See https://scriptedalchemy.medium.com/webpack-5-module-federation-stitching-two-simple-bundles-together-fe4e6a069716 -- both in Udemy and in the url here, it says "You have to ensure that your publicPath is explicitly set to the URL it originates from." . However, it is now possible to set public path for remote code from host machine. See https://webpack.js.org/concepts/module-federation/#dynamic-public-path
--|---- **IMPORTANT**: remote bundles are loaded async-ly, because they are not pulled in during the build-time, but during run time. For this reason, if you want to do anything with remote modules, you need to do dynamic imports! `import('remoteAppName/exportedModule).then((wholeModule) => {...})`. Within remote module, if you exported, say, a React component as a default export, then you can do `const ComponentFromRemote = wholeModule.default;` to get a handle to the component
--|---- **VERY VERY IMPORTANT**: Micro frontend via Module federation is a good example of why (1) js code should be arranged to be different for each feature, (2) each feature should share as less of code as possible, (3) For each feature, have an `index.js` page with list of features that is exported out. GENERALLY.. this is a good reason why code separation should be business domain first, and then then based on code-type.. rather than the other way round as is done many times
