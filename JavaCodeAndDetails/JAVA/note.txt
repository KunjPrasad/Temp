JAVA:


**** VERY VERY IMPORTANT: To profile application: try using Flight Recorder and Mission control. In prodction, it needs license but it free for developer desktop. Also, you can mix the use of AspectJ for logging, specialy around suspect methods.
See https://www.youtube.com/watch?v=yRTxptHqttA   for many subtle code changes.. but remember that in most cases, one should not make code extremely lean and unreadable just to squeeze performance - because in overal context somewhere a disk access will hit the system and will single handedly increase timing by a lot!! So with respect to overall process, you'd be making small change by nitpicking
Can also see: https://www.rockvalleycollege.edu/webadmin/upload/Top-10-Java-Performance-Problems.pdf


**VERY VERY IMPORTANT: How to design a good API  Joshua Bloch : https://www.infoq.com/presentations/effective-api-design
---- Start API design by getting requirements - 1 line. Identify what could be possible uses and enhance API, but not too much - let's say not more than 1-2 if-else/filtering criteria. 
---|---- API NAMES MATTER A LOT - should be small but explanatory! Similarly, use consistent wording. Avoid 2 verbs that are close to each other in common meaning! Like, don't have delete() and remove() both!!! Method name should be verb - and method should ONLY do that task. If it is doing something else/more find a better name. Member name should be noun. For methods, keep consistent ordering of inputs. Like, keeping source argument before destination argument - always. Another example, when making ClassUtils api - for each method, have the first argument to always be "Class" object
----|---- DOCUMENT EVERYTHING... for class: Tell what it represents. For methods: what the method does and to what state/ precondition/ validation/ postcondition/ concurrency/ side-effects/ concurrency-side-effects. For members: what it represents, units, acceptable values. DO NOTE REDUNDANT-DOCUMENT, for example: account number, don't say it has to be alphanumeric only. Just say, "serde/validation considerations guided by.." and name of unit doing serde and validation. If getter/setter doing defensive copy, say so..
---- API should do 1 thing ONLY, and do it well!! (remember, if at all, you see multi-branching, make it interface / abstract class / SPI like structure or separate utils class -- see below). 
---- WHEN IN DOUBT, DO NOT ADD ANY EXTRA FEATURE TO API. It can always be done later.. don't be eager
---- When making modules, ensure to have a DAG structure without circularity. This involves starting with identifying business components, and injecting particular implementation providers within them.. Utilities can be specific to certain task, or to global codebase!
---- API should give "functional details" and not provide any other specific on implementation details. For example: JAVA maps is a key-value set. No more. If API coding sees use of constant - then they should be logical constants, like "days_in_week", not arbitrary constant, like divide array in 10 parts and subdivide task. Either try to replace "10" by logical constant, not data-size based constant; or use SPI-like structure (see below) to inject a particular implementation
---- When making a structure that can have algorithm based implementation, better to make it an interface and then add different implementations. A nice example might be to say that Strings as "Hashable" and then implement different String-Hash implementations. 
----|---- One thing to note in above is that "String" class contains many functions and hashing is oe of them. We don't want to repeat every other method of String just so that we can make a new Hash function. There are 3 options in this case: (i) Make an abstract class that defines all other methods and then 2 implementations define corresponding hash methods. (ii) If the original class cannot be made into abstract because it needs to be usable, then use a SPI structure (SPI = service provider interface, where users can attach custom implementations, like done with JDBC). (iii) Make a separate Utils class with static methods. This way, the main object is simply a data store with get/set methods - no algo. The Utils class has methods based on algo. Once can even add SPI like structure in Utils-class methods. In line, keep small parameter list - at most 3 (use Builder and/or helper class with partial fills)!!
---- Don't let API implementation details leak. This involves, taking care when serializing, leaky reference during constructor - particularly by use of anonymous class. Use private constructor when class connot be instantiated. Make methods final where necessary. Define private readObject and throw error to hinder serializability and/or make objects transient. Keep members private as much needed; if not private then package-private which is way better than protected.
---- Another place to prevent leakage of implementation details -- when throwing exception, don't throw generic exception or those checked by Java - but special ones designed for a process by you. Also, define related exceptions in the corresponding package; if needed, you can also make hierarchical structure in exceptions to make the results look more intuitive. Translate Java exceptions into ones that are suitable for code. VERY IMPORTANT: Throw checked exception when there is a way to continue processing after exception, else throw Runtime Exception if there is no way to deal with it - because fail is owing to special case and for particular set of inputs only given to code. When throwing exception - try to provide as much information possible!!
---- To keep code clean during Multithreading - use volatile, define locks and use it.
---- Avoid sending objects, sending basic data types are better if it can be helped
---- **** Liskov Substitution principle: UNLESS YOU CAN DEFINITELY SAY that class-B "is-a" class-A -- without any catches or caveats, do not extend Class-A to make Class-B
---- Use functional objects to hide boilerplate code. Do not make client do the work that the module should do. This once again goes in line with principle that api should do 1 thing, and do it good, and that thing should be based on logical/functional perspective and not on inside implementation.
---- API should fail-fast, throw exception as soon possible. Do all validation first - hold locks - to ensure that only runtime errors can happen and nothing else. And that if there were any other issues, it is caught is validation early on. THIS ALSO ENSURES THAT DATA IS LEFT IN CONSISTENT STATE ON FAILURE
---- If you are returning a bunch of data in string, provide method(s) that parses the string and returns individual components used in making full string. DOCUMENT THAT USER SHOULD NOT PARSE STRING to get individual values
---- "Proxy to hidden collection" pattern: See last 2-3 slides from https://www.infoq.com/presentations/effective-api-design  on ThreadLocal. More details below


**VERY VERY IMPORTANT: Note the difference between forwarding pattern and composition-with-single-member. In composition, one cannot use the composed class instead of the original class. For example, in Joshua Bloch's book example, the forwarding set is a DECAORATION on top of a set, but the new class is still a set! Just like decoration of streams to include buffer, cipher, compression - by being a "forwarding" class, different decorations can be mounted on top of each other. This is not possible with COMPOSITION


1) Try to keep code in main() method in a declarative style, so that it is closest to business requirements, without bringing any code-logic. If possible, then keep declarative elements even in the methods that were used in main itself. The idea is to push code logic as low possible to foster modularity and reuse. This also fosters easy code check. Also, this enables the business to be more involved in code, which in turn may prevent misunderstanding between business and coder.
---- (1.1) In Java implementation, one cannot make tuples, so user-args check and assignment has to be done separately. Note that in Python, even this can be abstracted out.
---- (1.2) Note that it may be tempting to define outList as ArrayList within main, and then call a method to populate each entry. As said in this point, avoid doing so. One good example of why it should be avoided can be seen here, wherein,  due to logic-separation, one can essentially change to Java8 style use of lambdas but not touch/change main method.

2) **VERY VERY VERY IMPORTANT: Note to not blindly use getters/setters on objects because they pass reference. Also, avoid the use of clone() and shallow copy methods. While they may be suitable for some cases, they may be unsuitable for many other cases and you don't want to set a bad precedence. 
FINALLY, when copying objects, use appropriate synchronization to ensure that content of object is not changed while copying. This is useful in multithreaded process. When using synchronized-blocks, sync on the original object that is being copied and should remain unchanged. Do not sync on one being newly created. This causes different object to be used for syncing in getter and setter. By Joshua Bloch's and Brian Goetz's notes, the construction is good (except, See #2.3 below)
---- (2.1) On same lines, do blindly make getters/setters. Always ensure any method is thread safe by virtue of immutability or single-access. 
----|----ALSO, see definition for map-setter. Here, we want both the map-member and map-argument to not change when setting is done. HOWEVER, if we synchronize on 2 objects, one after another, there can be scenarios that create a deadlock - example, if any operation defined on argument-map uses synchronization on member-map (See: Dining Philosophers), or if some other thread calls the lock on two objects in different order, also see example below of Frankenstein/Igor call.
	* This example also shows importance of defining map as empty in default constructor rather than as null. Now, in setter, one need not sync on the method, but can call sync-block on the member-map which is guaranteed to be non-null, so a lock can always be made. This also shows how "special-setting" calls for special validation: Since we want the map to never be null, we need to guard against incoming map-argument of null. But frankly, there is no sync-guard on it, so it can change between the time the check is made vs when it is used!!
	* VERY VERY VERY IMPORTANT: Solution: The solution to above is to wrap each object with a lock in new encapsulation. This lock can now be used to periodically tried for, such that if not available, the attempt is halted for some "random" time, then retried - to prevent deadlock. Over here, the type of argument in map-setter cannot be changed - it is a map. So, we can encapsulate an object with member-map, which just means adding another lock-member. The only other access of map is in getter-method, so a lock will also go there. This ALSO HIGHLIGHTS the importance of preventing reference leak. By containing leakage of member-map reference, we are now able to enhance it further by putting a lock. This couldn't be done if reference leaked to some other method - and we could have had possible deadlock scenario. ALSO, make this new map-lock as immutable by defining it only in constructor, not leaking reference via getter, and not enabling change via setter. Also, keep map-lock as transient because it is not pertinent to object-content but is an internal execution detail. 
	* VERY VERY VERY IMPORTANT: NOTE the details in THE SETTER implementation. First get lock on argument-map and not member-map-lock. This is because argument-map is an external variable and need to be handled first. Do so only if the argument-map is not null. MapLock is internal lock and is always guaranteed to be "eventually" available - it could be unavailable at the time if it is being used in getter-map method, which is bound to end soon after which the lock will be free. Being an internal feature, there is no way any deadlock can prevent the free-up of this lock. THIS ALSO HIGHLIGHTS THE IMPORTANCE OF NOT HAVING MORE THAN ONE EXTERNAL FACTOR THAT CAN VARY AND NEED TO BE SYNCED, and should be practiced in code design. For internal factors (i.e. internal locks), they should be used in all methods such that there are no external-lock-sync inside them. This guarantees that internal lock will always get eventually released and be available to other methods. ADDITIONALLY, always place internal locks in same order to prevent deadlock - Since they are internal, this is a controllable aspect, otherwise just use one inetrnal lock only. Finally note to put it in try-catch when trying to get lock on external object BECAUSE between the time of initial if-else check (to verify that the argument-map is not null) and getting sync-lock on it, the object might have changed. Using another if-else is useless because of same reason. So just put a NullPointerException, then catch and process it as if incoming map was null.
----|---- For example: Igor waits on Frankenstein nod, and if he himself is free, before he answers to a call. 
	* Frankenstein calling Igor is like re-entrant scenario where he first calls, then nods. 
	* Consider when someone else calls Frankenstein, then Igor and wants to proceed till he hears from Igor. There is a deadlock because Igor will keep on waiting and not respond because Frankenstein is occupied till calling-person is done. And calling-person won't be done till Igor responds!
	* Consider when someone else calls Igor and then Frankenstein, then there is a "race" to "deadlock". If other person is able to call Frankenstein first, a deadlock happens. If Igor is able to call Frankenstein first, there is no deadlock. 
VERY VERY VERY IMPORTANT: Search for "LOCKING, IMPORTANCE OF DEFENSIVE COPY" and "ANYTHING ELSE, ANY LOGIC SHOULD ONLY BE" below and read the points on object design and having thread safety
---- (2.2) See Pdf Page 306 of Joshua Bloh's book: Use double locking with "volatile" keyword on underlying field if that is to be shared among different threads. Also, see the pdf wth IBM Developer notes on JavaMemoryModel and use of volatile to ensure that changes in one thread are visible to other. Particularly, continue down to listing-4 in the IBM-notes. It shows the different "machine calls" invoked and how async cache flush in JMM can cause issues with object state seen by others
---- (2.3) VERY IMPORTANT: if reusing getter/setter methods in constructor, then follow logic as given in JoshuaBloch's book and make them final. This is done to prevent anyone from subclassing the class and changing definition of methods. This can allow leakage of reference if overriden methods are designed poorly. 
---- (2.4) VERY IMPORTANT: On similar lines as #2.3, see the IBM-notes on safe constructor formation. DO-NOT put any logic inside constructor. Constructor is simply constructor. If you need to put logic, then make a static helper method, or, do so via builder pattern - but not in object constructor. SPECIALLY, be careful to not put any logic exposing anonymous-inner-class or nested-inner-class objects BECAUSE they do contain reference to "this" pointer and can cause leaks. FURTHER.. in context of SPARK, remember that using such methods can trigger serialization of entire class - bad thing to do!!
---- (2.5) VERY IMPORTANT: When trying to get locks, it is always a good practice to get lock for some (mean + random) time, then relinquish control for (mean + random) time and then try again. This logic highlights the importance of having separate locking objects rather than locking on some other object. 

3) Note that outFileName is not defined until much later in the code. Define quantities only when they are needed and not before - just because you can define earlier. Most likely, even if it makes "logical grouping sense", do not define a quantity unless needed.

4) In Java, when making a bean, ALWAYS put getters/setters, toString(), equals(), hashCode(). In adition to it, DO NOT put any extra logic. If you think some extra support methods could be added, then make new static class, with Bean name and suffix "s" added, and add the support methods there. BUT, do not add any logic in bean class.
---- (4.1) Note that in code, the serialization/deserialization logic has been separated from bean to separate class. IS THIS GOOD?~~~~




ADDITIONAL TIPS:

**** To convert integer to bytes, Integer to hexStrin, viceversa,... see http://stackoverflow.com/questions/2183240/java-integer-to-byte-array and http://stackoverflow.com/questions/6374915/java-convert-int-to-byte-array-of-4-bytes    The main idea being that ByteBuffer is easily able to do this - so the same can be done for other types also. Also, note that Integer class itself has a toHexString method.

**** IMPORTANT: To control the number of floating values being written to JSON during serialization, either (1) use a custom string format, (2) extend JsonWriter in gson and its value(double d) method such that only a few digits are written (this is not mentioned as a good method because JsonWriter is not supposed to be extendible). Since CSV passes an array of Strings, at least it is easier there. A last option can again be to use serializatio proxy pattern

**** VERY VERY VERY IMPORTANT: Implementation detail: 
---- See https://docs.oracle.com/javase/tutorial/java/IandI/nogrow.html and https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html   Java Interfaces now have default methods, static methods, constants allowed within them. Default methods can be let as-is, made back into abstract form, or overwritten by a new default on inheritance. EVEN "ENUM" CAN BE DEFINED WITHIN INTERFACE
---- ****VERY VERY VERY IMPORTANT: Look at the end of https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html where they gave examples on how to create modular and better comparator. Even more important is to realize that modularity can be realized in a much better manner with the use of Java-8 Function chaining and lambdas, also including Method Reference (https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html)

* VERY VERY VERY IMPORTANT: For different kind of references, see: https://community.oracle.com/blogs/enicholas/2006/05/04/understanding-weak-references    Also remember, we have "AtomicReference"!! and also threadLocalObject. 
---- Phantom references can be used to debug if there are long lived objects in case a OutOfMemory exception starts coming. Code example: See https://gist.github.com/nhachicha/4ba780712a7ae179cc67 (but remember that calling .gc() need not necessarily trigger it as done in code)
---- Soft Reference can be garbage collected after there are no strong references to the referent. However, it typically retained until memory is low. All softly reachable objects will be reclaimed before an OutOfMemoryException is thrown. That's why they are better for cache-use compared even to weak reference. Nice page: http://stackoverflow.com/questions/264582/is-there-a-softhashmap-in-java    Identifying how long soft references stay: http://jeremymanson.blogspot.de/2009/07/how-hotspot-decides-to-clear_07.html
---- Weak Reference : As said in Joshua Bloch's book, it is good for use with listeners
---- See "FinalizableReference" in Google Guava http://google.github.io/guava/releases/snapshot/api/docs/   Search for Soft/weak keys in Guava cache: That option is there: https://github.com/google/guava/wiki/CachesExplained

* Avoid defining null list/set/map, even in constructor. Just use empty objects. This prevent possible NullPointerException

* When defining overloaded constructor, prefer getter/setter method reuse to capture primitive logic in them, rather than simply assigning incoming value to class members. Over here, the setter has sync-logic and using it makes the constructor thread safe. The same logic is also reused in builder class. Do note that ideally when you use builder class, then make contructor of original class hidden.

* Prefer use of synchronized-blocks to synchronized-methods. Latter synchronizes on entire class and can be unnecessarily restrictive

***VERY VERY IMPORTANT: As mentioned in comments, in the IBM-notes on proper "constructor" construction... Object is a collection of "instance" members that represent value "at an instance". So a good code should always endeavor to ensure that object member's value at any instance is never undefined, or face race conditions. This ideology directly contradicts with the functionality of "methods" in an object that aim to change member's values. The way to restore harmony in two concepts is by ensuring that for all practical purposes, only one method is called at a time so that no outside functions catch the object in an inconsistent state. Thus, the need for sync-ing. HOWEVER, we have additional complications: excessive sync-ing causes slowdown, We need to ensure that multi-processing system with weak-memory-model see the correct values of shared object at same time, and we need to avoid poor sync-ing that may cause deadlock/repetition (threads continuously working but not making progress; Example: two people come face to face, both move to left - still face to face; both move to right - still face to face). This brings in need of sync-blocks, making new objects as monitor locks, use of volatile keyword, double-checking. Finally remember that unless an object is sync'd, it's value can change. So something that was just checked as not being null, can suddenly become one - this can be accommodated by wrapping synchronized() block with try-catch of NullPointerException. Lastly, if the actual work scenario is much controlled, and there cannot be concurrency issue, then just make a comment of class not being thread safe, rather than making all the mods that makes code complex and will never be used!

***VERY VERY IMPORTANT: Above point mentions how methods are responsible for causing transition in object member values. Always try to leave class in consistent state, including, leaving in consistent state even if an exception might get thrown. Thus, a good design should start by acquiring locks if needed (so that entry don't change between subsequent validation and later execution. There can still be errors - like File class returning null value for listFiles() because max open limit suddenly got crossed!), validating inputs, and then performing execution. Execution is done at end so as to give maximal guarante that nothing will fail because it has been validated. There is one more aspect. It is preferable to first define and obtain NEW values for all members that will be changed. After that, create a block that assigns these new values to original object. This way, the original object is left in a consistent state even if some unknown error gets thrown when getting new values. If not, then definitely the assignment step will go smooth and object will still be in a consistent state.

***VERY VERY IMPORTANT: String Normalization: Note that unicode can have multiple ways to represent same character. Thus, accented-a can be one character, or 2 characters of (a -followed-by- accent). The act of normalization/denormalization constructs or breaks the characters into composites - thus ensuring consistency in what search results see.. In this context, useful classes are java.text.Normalizer (https://docs.oracle.com/javase/7/docs/api/java/text/Normalizer.html) that can be used for composition/decomposition. Also, additional details can be found on Wikipedia (https://en.wikipedia.org/wiki/Unicode_equivalence#Normalization)
---- On similar lines,to strip accents, see: http://stackoverflow.com/questions/3322152/is-there-a-way-to-get-rid-of-accents-and-convert-a-whole-string-to-regular-lette     and Apache Commons StringUtils.stripAccents(input)

** Binary file vs text file: Note that when directly writing bytes - that is binary file. When writing text, that is text file. In Java, remember that it is always a good idea to write independent records and forgo the link structure between objects - in fact, if link structure is needed, it should be emulated via used of common "join key". Such modeling brings "file output" close to actual database modeling making program more flexible. This is also important because in end, every prod system needs to use Database. After reading from DB, another follow-up util can create in-memory objects links to emulate data join. Same can be done to complex data structure via a preprocessing utility before writing complex objects to file.
---- Look at Serializable vs Externalizable (http://stackoverflow.com/questions/817853/what-is-the-difference-between-serializable-and-externalizable-in-java)

**** VERY VERY VERY IMPORTANT:: LOCKING, IMPORTANCE OF DEFENSIVE COPY --AND-- role of Business logic: By using defensive copy, an object is left as its own individual unit where its members reference are not leaked. This again falls in line with design decision given above of trying to keep as many independent units as possible and not letting them mix!! Now, generalize the concept further - if every unit is independent, then how do they interact - and this brings in role of transfer objects. Now, when making defensive copy of objects with deep nesting, like, copying Map.. it is better if the getter/setter do not implement the logic, but it is done by business object that has the original Map object, and now wants it stored in a new object as member. This provides better separation of logic, where object-creation is responsible only for that object creation, and related complexities are handled by framework that is creating object. The object will now be responsible for just managing its own internal locks! Hence, a separation of logic!!
If the business object is part of multithreaded execution where different threads need to access and lock group of objects at same time, then those groups should be made into a class and handled via internal lock. Once again it ensures that when getter() is called, then all class is locked while the results are being transferred. IF, the logic is such that an object consists of say, 5 map members, and different concurrent threads want to read different subset of members - then a nice design would be to make single object with 5 "VOLATILE" members and 1 internal lock, and then expose various methods returning partially filled instances of same class in getter (created via defensive copy). This ensures correctness in execution. ONCE AGAIN, THE CLASS IS RESPONSIBLE FOR MANAGING ITS OWN INTERNAL LOCK. Now, if the business object makes change to a map-data previously read and want to set it back, then the business object is in control of map-object and ensures that it is thread safe, since it is being used by only that thread, and so can be set. This brings back to situation where class is not required to lock on external object - but only on its own member.!!!

**** VERY VERY VERY IMPORTANT: (...continuing on above) consider the case when a thread creates 2 map objects, adds them to an object, and the object is used for sharing. If following above design, the 2 map member of newly made object should be defensive copies of maps made by thread and passed as arg to constructor or setter. This way, the newly made object is totally independent. Now, even if the original thread continues to manipulate the 2 maps (not the members of object), it won't be touching the content of object. And when it calls getter/setter - corresponding locks are called, just as done by other therads accessing the object. The point being - always ensure that references of object's members are within that object only and do not leak out in any way. ANYTHING ELSE, ANY LOGIC SHOULD ONLY BE ABLE TO GET REFERENCE TO OBJECT AND NOT TO ITS MEMBERS. SIMILARLY, OBJECT MEMBERS SHOULD NOT HAVE REFERENCE TO ANYTHING OUTSIDE THE OBEJCT
ADDITIONAL ADVANTAGES of above: (FIRST) When a class is made as above and shared, then it can now be defined as "final" peventing any thread from making it as null and thereby breaking logic for others. (SECOND) Even if the members are assigned null value, the object itself won't be nul, and the locks will also continue to exist. Thus, concurrent logic does not break. (THIRD) Based on this logic, do note that whenever you are accessing any data that is not locked - it can become null. An important case is File.listFiles(). It can work on directories, but can later fail if there aren't many threads available!! When making sync-locks on these objects, try-catch it with null pointer exception, because by time lock is called, the object might have become null.. but then, in ideal processing workflow cases, as described above, such kind of situation should NEVER arise as long as every therads are properly made. (FOURTH)***VERY IMPORTANT: See Pg288, Item-67 in Joshua Bloch's book - he says to never cede control to client in sync block. By using a design with only interal locks use and defensive copy, one TOTALLY PREVENTS such scenario because an object will only be calling its internal locks, and thus will have full control over concurrency.
***IMPORTANT - this should be an important design consideration on when to break a class into pieces and develop a composition -- the answer: unless "internal lock only" implementation is acheived; If not, then continue breaking classes and making "utility" class comprising of pieces as composition
Pg303 - Joshua Bloch - when making internal objects for locing - ALWAYS MAKE THEM FINAL. This gives additional guarantee on immutability without which one can simply change the referenec of locking objects and cause sync logic to fail. FURTHERMORE, DO NOT have getter/setter on locks outside constructor that can cause leaks. No need to keep them volatile, since they are the sync-target. In keeping with line, mark them as transient - and define define them when reading from serialized file.

**** VERY VERY VERY IMPORTANT: (..continuing on above) As mentioned in Joshua Bloch's Pg313 - serialization mechanism is like using constructor. SO.. all care that is taken in construction of new objects should also go in object contruction via deserialization. Simlarly, prevent reference leak - in serialization this can be more important because we only want to persist user data and no internal logic, marking fields as transent. Still, using default serialization technique will cause leaks of private methods - thus always use own serialization, or make a special case with simple javabean structure for serialization. 
---- As said on Pg314, classes with inheritance should NOT implement serializable. This is another reason why composition should be preferred over inheritance. Pg315 says that since classes can be extended - so even if original class wasn't serializable, the final one might be. THUS, ALWAYS GIVE no-arg constructor on ANY data-object -- even if you have a builder pattern available. Since "Utils" provide only business methods, they can be left unserialized - so just give it private constructor. Also see Pg334, where, if readResolve() in superClass is protected/public and subClass does not overwrite it, then the object formed after resolving iwll not be subclass object, but superclass object!! Thus, using composition is once again better; Or use simulated multiple inheritance / forwarding, but creating custom logic properly
---- Special method ReadFields()/PutFields() - Pg313 (See JavaDoc, it can be used to read/write default values is none available in stream), readObjectNoData() - Pg314, defaultReadObject() can be used in combination with readObject() defined in a class to guide how to construct transient values from serialized values - pg316, 319. @serial tag for javadoc, and the reason for java-doc'ing private fields - Pg319, readUnshared/writeUnshared() - Page 330 -- DO NOT USE, 
----|---- Why readResolve, readObject, readObjectNoData, etc are all private methods. So that if a class is subclassed then methods of cubclass do not override superclass: http://stackoverflow.com/questions/7467313/why-are-readobject-and-writeobject-private-and-why-would-i-write-transient-vari
----|---- Note, if after initialization of class, some fields should be given special values and not default int/string/object values - just define this logic in no-org constructir rather than changing readObject(). ALSO NOTE that readResolve() is different from readObject() method defined under a serializable class. FURTHERMORE, readObject() of inputStream is different from readObject() of a serializable class; but the former implements by calling the latter
----|---- VERY VERY VERY IMPORTANT: Note the code and comment in Pg321 - When making custom read/writeObject, one should ALWAYS put read/writeObjectDEFAULT as the first method. Why? The need for readObjectDefault() comes because if the default object is not written first, then deserializing thread will never know what object is being referred to. By reading the class type, it creates default instance and knows which class' method to use when going through additional processing by readObject() logic. And for readObjectDefault() to be successful, it is necessary to writeObjectDefault() first. "If defaultWriteObject or writeFields is not invoked once prior to the writing of optional data (if any), then the behavior of instance deserialization is undefined in cases where the ObjectInputStream cannot resolve the class which defined the writeObject method in question" -- http://stackoverflow.com/questions/16239239/why-does-the-defaultwriteobject-function-have-to-be-called-first-when-writing-in  Lastly, also note that if the serialization/deserialization sequences are not consistent, it will throw StreamCorruptedException
----|---- Page 323: Using "synchronized" keyword to ensure that object is thread-safe and any changes made are immediately flushed to memory!!
----|---- Page 327: IMPORTANT: If there are any data checks in constructor, then those checks MUST ALSO go in readObject() method
---- Page 320 -- stackOverflow when using default java serialization: another reason to not blindly use Java serialization and store full object graph, rather store each entry as independent
---- Page 329 -- VERY IMPORTANT: Note that defaultReadObject() uses Java's deserialization logic which "has inbuilt" feature of doing graph resolution of objects. So it is possible to append extra bytes and steal reference by creating extended graph structure. This is similar to how Java methods do call-by-reference and share references. THUS, whenever copying MUTABLE data, set the values to new variables, discarding what was initially read from stream - since that can have its reference stolen.
---- See Serialization specs: https://docs.oracle.com/javase/7/docs/platform/serialization/spec/input.html#6014   resolveObject() allows stream dependent substitution of serialized object and is called after readResolve()
---- Page 335 -- VERY VERY IMPORTANT: Use of serialization proxy and disabling the "serializability" of original class, thus enforcing the use of proxy only! Once again, the object can further be used with composition rather than taking original/proxy to inheritance (Pg338 mentions inheritance as a limitation)

**** VERY VERY VERY IMPORTANT: Code on Joshua Bloch's Pg315 -- for the code to work, note that AtomicReference<> should be initialized first, even before constructors are initialized. Thus, note the order. ALSO - note the class "AtomicReference" and its methods - compareAndSet
---- VERY VERY IMPORTANT: This pattern of having Enum-atomicReference is also a good pattern when testing a class for thread safety and checking if it is not getting called before initialization

**** VERY VERY VERY IMPORTANT: (Theoretically).. When making private constructor to prevent instantiation of a class - then throw an AssertionException inside it - this prevents reflectively calling private constructor. Or better, just communicate via serialized data. Plus, you can add encryption and/or compression in proxy.

**** VERY VERY VERY IMPORTANT: FOR CALLBACK FRAMEWORKS... 
---- Firstly, In Pg49 of Joshua Bloch's book, When using callbacks - make them as key of weakHashMap, and keep the Map in object responsible for handling callbacks. Also, note that Java has Collections.newSetFromMap() that is used to make set from Map. Over time, stop using Set, and just use Map!
---- Secondly, and IMPORTANT: Note that observers are made by outside code and then "injected" into the class. In case of callback, it is necessary to do injection. Same is also true when making a shared object and sending to all worker threads. In such cases, after the injection/sharing is done, do make sure that the original thread making the object before injection/sharing does not "share" (i.e. leak) the reference of object to someone else. If the original thread now continues by assuming role as one of the worker, it can continue to use object. But if this is not the case, or if no logic needs to be called after all multithreaded operations finish on the shared object, which is particularly the case with callback-object-injection ..then set the variable holding the reference to injected object as null, so that the object refrence does not get leaked to others. Setting to null means that the injected object was initially strongly linked to original variable, then it was shared in 2 variables/objects/members (...even in same thread) and finally the first relinquished control, so it was bound only to second one. This just keeps logic clear. 
---- Thirdly, and VERY VERY IMPORTANT: "DO NOT HAVE CIRCULAR REFERENCES IN CODE" Look at code on Pg288/289. The class has a list of observers, and a method that passes to each observer the reference to the holding class. Thus, there is circular refrence of "class->list->observer->class". Do not use circular reference. In best case, it can cause undesirable logic execution, to deadlock, to worst case of "concurrentModificationException", or even while leaving data in an inconsistent state (Pg.291 self-example). Also, as said on Pg290/291, it can either cause concurrentException or deadlock - so the concurrency behavior is not consistent. Another way to see such cases is when re-entrant nature of locking is used. This is bad because if another thread were to do the same, then that'll cause deadlock.
----|---- Note that circular reference can also manifest itself, through indirectly, when using inheritance. In inheritance, one can always achieve lock ordering if subclass always uses new set of locks which are obtained before calling super() methods that only use locks defined in parents. But, in a more general case, by overriding inherited methods and changing lock order, or by reusing locks of superclass, one can enter a scenario where deadlock may occur if locks are not re-entrant (See Java concurrency in practice, Page 27, Listing 2.7). An example of latter can be if super.Method1()'s logic is wrapped by a lock, and when we do inheritance, we want {@Overide}subClass.Method1() logic also wrapped by same lock. THUS, ONE MORE REASON TO AVOID INHERITANCE
----|---- HOWEVER, we DO need such an implementation for observer pattern - so how to implement? To avoid inheritance related lock-out, best solution is to avoid inheritance totally. WHAT ABOUT CALLBACKS IN GENERAL..
----|----|**** VERY VERY IMPORTANT: In general, whenever there can be a circular reference, one MUST ALWAYS use asynchronous operations to break the circular nature by causing temporal discontinuity. For code in Joshua Bloch's Pg288/289, this would mean that calling notifyElements() happens as follows: (1) obtain lock and don't lock on a member using sync-block, (2) iterate through list of observers, however the .added() method should not be given "this", but link to a private queue where they add the method name and args that need to be done, (3) Now the loop over listeners and call .added() for each listener. VERY IMPORTANT: This step should return a future, its like submitting tasks in queue that will be processed by main thread itself, but after the looping over listeners is finished, i.e. tasks to do have been added. NOTE, the lock is still held by main thread, (4) Now go over the private loop and execute all methods in queue - NOTE that processing may invoke class methods which try to call a lock again -- and this is why Reentrant locks are needed. It just means "locking with priority", where holding thread has a priority on set of task executions. (5) Once the execution is done by iterating over queue, the future given to therad in step (3) gets necessary values, in case of example, it is just void values - See example below.
VERY IMPORTANT, NOTE: For above design to work, there should be (i) as many "internal" queues as unique data members involved in circular queue, (ii) internal queues should be private and should not be callable from outside, (iii) Same lock should be used for data-member involved in circular reference and corresponding circular queue - both may be encapsulated as one, along with the lock. ANOTHER WAY TO THINK OF ABOVE.. is by realizing collary to Scala Stream object that does not break under circular logic.
Also note that in case of example in book, one can still get concurrentModException if one tries to iterate over list to effect a deletion - this highlights that the arguments given to effect pending calls by .added() should specify individual calls-method and element as target. THIS IS IMPLEMENTATION DETAILS.. at least note that calling it via same thread or different thread (Pg290/291) won't cause different errors - this gives consistent behavior.
----|----|**** Note that above "circular logic" should be distinguished from "parallel branching" of logic: Consider Mater-Slave-Client architecture where Client can directly contact Slave unit and give task to it. However, Slave accepts tasks only when Master has no task for it; Master itself can be a client too. Now consider scenario where Master issues task - one can say that slave thread wil get trapped because it will try to contact master to ask if it can take task, but master won't return result since master is waiting for slave to say that it can take task!! The simple solution would be to put a logic in Slave where it does not query master if the entity giving task is the master! The point being - making queue and adding tasks is not always applicable - don't force it. 
---- VERY VERY IMPORTANT: Joshua Bloch's book Pg338 - note that in presence of circular reference, the "serialization proxy" pattern breaks. This is one more way to logically say that one should not have circular referenes in their code, or avoid if not

**** VERY VERY VERY IMPORTANT: Different level of Java Reference: 
See, learn, understand: https://community.oracle.com/blogs/enicholas/2006/05/04/understanding-weak-references
Also see Joshua Bloch's book, Pg49 - use of weak-reference for cache and in callback framework

* REMEMBER: wait(), notify(), and notifyAll() methods of object class must have to be called inside synchronized method or synchronized block in Java to prevent race condition. But a better option would be to just use objects from concurrent package rather than wait/notify.
OTHER INFORMATION: 
---- Use of interrupts: http://stackoverflow.com/questions/3590000/what-does-java-lang-thread-interrupt-do    Notice as said in the stackOverflow post and also on oracle tuorial - https://docs.oracle.com/javase/tutorial/essential/concurrency/interrupt.html   if the code has long running service and interrupt is expect, then the thread needs to poll for it explicitly!! At least this is one way to check for interruption. Other can be to simply share a map with flags (keep it volatile!!) On similar note, Thread.isInterrupted() cecks for interruption invoked by someone, but Thread.interrupt() interrupts a thread. Also realize that "interrupt" call interrupts the thread by setting a flag but not closes it -- DO NOT USE Thread.stop()!!
---- Note that Java has "Lock" object that can "lockInterruptibly" (i.e. try to fetch lock while drop the request if interrupted), or try fetching lock with timeOut. Considering how it is always said that for sync-block one should use a separate object.. a MUCH BETTER SOLUTION would instead be to always use a lock (or similar lock objects) from java instead of calling sync on an object. WHEN USING LOCKS.. always put them in try-catch block, with finally{} releasing the lock. That is one thing that needs to be taken care of when using locks rather than sync block

* NOTE that: the api in  java.io are blocking-io aplications. So, if a fileInputStream is opened, then the statatement won't return unless the file is indeed opened and ready for reading. So, it can never be the stream is opened but it does not read. However, do note that just because a buffer for stream is of some length, does not mean all of it will get filled as long of end-of-file is achieved.. buffer filling is a separate process. But again, buffer WILL show end-of-file only when underlying stream also shows EOF
http://stackoverflow.com/questions/611760/java-inputstream-blocking-read

* How can a server identify requests coming from different machines on same port? See: https://www.youtube.com/watch?v=6G_W54zuadg   and     http://stackoverflow.com/questions/3329641/how-do-multiple-clients-connect-simultaneously-to-one-port-say-80-on-a-server
The server starts with a "ServerSocket". This is a passive object that creates active "socket" object once a client connects to "ServerSocket" and server accepts it. Client themselves just make Socket after server accepts the connection. As mentioned in stackOverflow post, the connection is identified both by source and destination ip and protocol. So, once the server accepts and creates a socket, this is a different entiry for each client and so, teh server is able to identify different clients.
VERY VERY VERY IMPORTANT: Also see "Socket" description in (https://blogs.oracle.com/slc/entry/javanio_vs_javaio). It says "Upon acceptance, the server gets a new socket bound to the same local port and also has its remote endpoint set to the address and port of the client. It needs a new socket so that it can continue to listen to the original socket for connection requests while tending to the needs of the connected client." -- This further highlights why ServerSocket and Socket are different - one represents a connection while other stays separat so it can continue to listen for new requests
ALSO 
---- Why serverSocket is blocking, and implications: "The server waits for a client connection in blocking mode: serverSocket.accept() is a blocking instruction, the server waits for a connection and no other operation can be executed by the thread which runs the server. Because of this, the server can work in multitasking only by implementing a multi-thread server: having to create a thread for every new socket created by the server."

**** VERY VERY IMPORTANT: Difference between Java's io and nio?
http://stackoverflow.com/questions/10372066/what-is-the-exact-use-of-java-nio-package-when-already-methods-are-available-wit
"NIO allows you to manage multiple channels using only a single (or fewer) threads, but the cost is that parsing the data might be somewhat more complicated than when reading data from a blocking stream using standard IO. If you need to manage thousands of open connections simultaneously, which each only send a little data, for instance a chat server, implementing the server in NIO is probably an advantage. Similarly, if you need to keep a lot of open connections to other computers, e.g. in a P2P network, using a single thread to manage all of your outbound connections might be an advantage."
See Jenkov tutorials to understand how to read/write using ByteBuffer and NIO-channel class : http://tutorials.jenkov.com/java-nio/index.html and also how the finiteness of byteBuffer can cause issues ****BUT, it may not be much of an issue frankly - essentially read from byteBuffer into stringbuilder breaking when '\n' is achieved. Still, this shows the convenience of blocking i/o when only that is desired, and there aren't many channels.
On flip side, since the io is asynchronous, there always needs to be an end-of-file or convention on end-of-message, or it will never be known when the message content has been read
Most important, it gave channels and memoryMapping. For more info, see: http://www.onjava.com/pub/a/onjava/2002/10/02/javanio.html  ,    and https://coderanch.com/t/276094/java/Java-NIO (latter contains comments from author himself)
Also see 10 things that can be done with nio: http://www.onjava.com/pub/a/onjava/2002/10/02/javanio.html?page=2   Note: "Buffers were created primarily to act as containers for data being sent to or received from channels. Channels are conduits to low-level I/O services and are always byte-oriented; they only know how to use ByteBuffer objects."
VERY VERY IMPORTANT: https://blogs.oracle.com/slc/entry/javanio_vs_javaio
https://www.ibm.com/developerworks/java/tutorials/j-nio/
---- Why use ByteBuffer vs Stream: Streams can have irregular flow over network coming at undefined intervals. Once can put a code that triggers every time there is stream input, but that will continue to trigger. So it is useful to have a buffer to collect data and trigger operations when it is full/empty. (**VERY VERY IMPORTANT: A similar yet separate note, Buffered input streams read data from a memory area known as a buffer (not Java's ByteBuffer; the native input API is called only when the buffer is empty. Similarly, buffered output streams write data to a buffer, and the native output API is called only when the buffer is full. NOTE (by self) since buffer can be made smaller size than os pages, so using buffers gives better read/write speed for small filesize)   
---- "Buffers work with channels. Channels are portals through which I/O transfers take place, and buffers are the sources or targets of those data transfers."
---- "All the socket channels create a peer socket object when they are instantiated (java.net sockets). The peer socket can be obtained from a channel by invoking its socket() method. While every socket channel (in java.nio.channels) has an associated java.net socket object, not all sockets have an associated channel. If you create a Socket object in the traditional way, by instantiating it directly, it will not have an associated SocketChannel, and its getChannel() method will always return null."
---- IMPORTANT: WatchService/WatchKey is also NIO api
---- http://www.javaworld.com/article/2078654/core-java/java-se-five-ways-to-maximize-java-nio-and-nio-2.html : Once can have a logic that new server-accept connections get registered to Selector. This is helpful in chat server, because the logic can be put that on reading data from an channel, write to all channels registered with selector (if they are not cancelled). IMPORTANT - see MULTIPORTECHO example of the page

**** VERY VERY VERY IMPORTANT: Understanding memory Mapping: http://blog.thetaphi.de/2012/07/use-lucenes-mmapdirectory-on-64bit.html
NOTE: One way to read file is by using memory mapped buffer. One advantage could be that the data is not "re-copied" from Kernel's buffer to user's buffer if memory map is opened in read-only mode, see https://en.wikipedia.org/wiki/Memory-mapped_file#Benefits. As said in "blog.thetaphi..", once MMAp is used, the user application starts to use Kernel's file-space. Thus, the memory requirement of application can be reduced, giving more room to Kernel for more efficient implementation. See top line in http://howtodoinjava.com/java-7/nio/java-nio-2-0-memory-mapped-files-mappedbytebuffer-tutorial/ saying that "For conventional file I/O, in which user processes issue read() and write() system calls to transfer data, there is almost always one or more copy operations to move the data between these filesystem pages in kernel space and a memory area in user space. This is because there is not usually a one-to-one alignment between filesystem pages and user buffers.", and note the different mention of "kernel" and "user" space memory
Also see: http://howtodoinjava.com/java-7/nio/java-nio-2-0-memory-mapped-files-mappedbytebuffer-tutorial/  
Read this in conjenction with Java zero copy: https://www.ibm.com/developerworks/library/j-zerocopy/  
IMPORTANT Example: http://howtodoinjava.com/java-7/nio/java-nio-2-0-memory-mapped-files-mappedbytebuffer-tutorial/
IMPORTANT.. In Java, "Note that you must specify the starting point and the length of the region that you want to map in the file; this means that you have the option to map smaller regions of a large file."
From blog.thetaphi..: "If the data is only on disk, the MMU will cause an interrupt and the O/S kernel will load the data into file system cache. If it is already in cache, MMU/TLB map it directly to the physical memory in file system cache" and more importantly "We also waste no physical memory, as we operate directly on the O/S cache, avoiding all Java GC issues described before." Note in example that MappedByteBuffer.load() method is never called.. the OS does that!
On similar lines, see "Direct Buffer" in Java - another example of directly using Kernel's memory instead of Java's memory - and once again, using it for large files only    https://examples.javacodegeeks.com/core-java/nio/bytebuffer/java-direct-bytebuffer-example/
FINALLY, the benchmark: http://baptiste-wicht.com/posts/2010/08/file-copy-in-java-benchmark.html

**** VERY VERY IMPORTANT: Java 8 completable future -- Note it is like deferred/promise of javascript (http://stackoverflow.com/questions/14541975/difference-between-future-and-promise) although for the matching to be correct, there should be a subclass that allow user to bind success/fail handlers rather than get full control of completable future. Thus, completable future is like JS-deferred, not JS-promise
**IMPORTANT: Note that Java-8 lambda can itself return a function. Like: return () -> () -> {return value;}; See: http://softwareengineering.stackexchange.com/questions/254311/what-is-the-difference-between-callablet-and-java-8s-suppliert
---- Note that ForkJoinPool has commonPool() static utility to use a common pool!! ForkJoinPool example: http://tutorials.jenkov.com/java-util-concurrent/java-fork-and-join-forkjoinpool.html

**** VERY VERY IMPORTANT: Fork/Join-Pool vs ExecutorService and limitations of each
---- See tutorial on oracle: https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html  It also has an example code based on RecursiveAction: https://docs.oracle.com/javase/tutorial/essential/concurrency/examples/ForkBlur.java    Following example is based on use with RecursiveTask that returns a value and can actually call .fork() and .join() methods: http://tutorials.jenkov.com/java-util-concurrent/java-fork-and-join-forkjoinpool.html
---- Difference between forkJoin and executor: The difference shows up when tasks are of recursive nature. Consider the case for executorService. Say, it has 1 thread only. When original task comes, it occupies 1 thread. Say, that task forks into 2 subtasks. Now, each subtask will require a thread to get completed, but the only available thread is help up by main task - which won't complete till all 3 subtasks are done - a deadlock!! ForkJoinPool takes care of such scenario by reusing same thread, removing waiting tasks and adding subtasks. THUS, FORKJOINPOOLs are good when working on recursive async tasks. See http://stackoverflow.com/questions/29988713/difference-between-forkjoinpool-and-normal-executionservice
---- WHY/WHEN ARE FORKJOINPOOLS GOOD/BAD? As can be seen from 2 articles, the .join() mechanism of forkJoinPool has implementation issues: http://coopsoft.com/ar/CalamityArticle.html  and much more importantly with concrete example: http://stackoverflow.com/questions/10797568/what-determines-the-number-of-threads-a-java-forkjoinpool-creates   This means that when doing forJoinPool - either use RecursiveAction and not RecursiveTask - since the former does not have any .fork() and .join() methods. Or, if using recursive task, limit the depth of recursion - preferably based on number of processors (Say 3*numProcessors). On similar lines, to get number of processors, use "int cores = Runtime.getRuntime().availableProcessors()" -- http://stackoverflow.com/questions/4759570/finding-number-of-cores-in-java

* "Proxy to hidden collection" pattern: See last 2-3 slides from https://www.infoq.com/presentations/effective-api-design  on ThreadLocal
The key idea is that ideally to get a threadLocal object, one can make a map, and have each thread be assigned a unique "key" which it uses to add thread-value in map. Then, when thread needs its own value, it uses that key. But the key being chosen is arbitrary - and actually inconsequential to logic. So, redefine threadLocal as only be able to set a value and then get it later - but internally, there is a logic to generate unique key for each thread; and the implementation also uses a hidden map, not revealed to user, but used by threads to store value
Similar situation can be seen when server stores context object for a user. We know it is a map since different contexts are stored. But, with perspective of code, it needs to know value for only one context - of its own.
---- THUS, HIDDEN COLLECTION PROXY is applicable when overall the code needs a collection, but for a single request-chain, it needs only 1 value!