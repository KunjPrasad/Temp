Logging 
-- If there are any terms used generically in the industry, then use it and don't make new ones. For example, reusing UTM parameters
-- Log with ML and quantification in mind. Setup a A/B testing framework that is based on results from analysis of log. For any new feature you add, the product and engg team MUST identify what is a related metric and then capture it in log, and do analysis ---- Generally product team adds new features based on anecdotes or UX result which is small sample. And this is good for beginning. However, things must evolve to point where you do proper log capture to get high data and then quantify if things are working as expected. This is something that can conflict with product because now they want to push out new feature.
-- When a request comes.. if you identify that certain data will be an invariant throughout the request and you have found that data in service layer, then add it to request level log container so that it can be logged!


When sending out email.. best to condense all information in single table from which email can be formed. This pinches down the common point between main application and external communication down to one point!


Vulnerability: https://stackoverflow.com/questions/50709625/link-with-target-blank-and-rel-noopener-noreferrer-still-vulnerable


Interviewee: Ask about integration between product and engineering. How is the roadmap defined? Ideally engineering should be working in tandem with product, using data to make decisions to go one way or other. If product is like a quarter ahead of engg, then its not quite agile. This also shows up in testing methods. Ideally, the testing / deployment pipeline should be as much automated as possible. If the time between "ready for release" vs actual release if large, then its not quite agile. If product is quarter ahead of engg, then the team isn't quite agile.. changes would be slow. But even when they work in tandem, ask how much engg has a say in identifying tickets. If engg has low/no say, then the codebase is likely to be awful because the push will always be on product. 



Interviewee: just like in a driving test, it is suggested to "highlight" the acts of being safe driver so that the tester can identify it and score accordingly, think of tech interviews as highlighting your capabilities to handle tech issues. Sometimes the question given does not allow for much latitude in showing such skills, but do so none the less. So, you should highlight concerns of modularity, reusability, parallizability

In OOP, there is an object that can change state via a method. But what about collection of objects? Does a method acting on a collection of objects allow each object to be independently changes - making it parallizable? Or are there external depenencies. This is where functional programming based coding shines. It makes it easy to identify what can be parallelized.. and does not have external dependency. So, when coding keep this in mind.. show it - highlight how it is used



UI -- accessibility: Put care to layout h1, h2, etc... navigation, main content... When writing description of something, like a job posting.. it may be good to add "screen reader" only fields that are not otherwise visible but are good to guide users. For example, instead of having the screen reader say "Software engineer; Google; Sunnyvale CA; $50 - $ 60 per hour; Engineer with experience in...", have it say "job name software engineer; company Google; location Sunnyvale, CA; pay rate $50 - $60 per hour; job description Engineer with experience in...", such that the field names like "job name", "company" etc. is read by screen reader but is not visible on screen. This is for better user experience. This also brings out that while you may want to show data as card, or any other fancy element.. it may be useful to format and consider it like a table, to improve site accessibility




Testing: 
- For "utility" methods, they can be tested on it own and not as part of a functional integration test over a service. Why? - the catch is that a utility method is supposed to be something that is getting called multiple times in codebase. So, it is a static method, not bound to a request, that does something. First of all, if you are having a utility method that is called at just one place in code, that's wrong.. it should have instead been a private method (and you don't test private methods). The code redundancy that is being removed by testing utility method in its own is that if it were instead tested as part of service in a functional test.. then same tests to check the behavior of utility method will get repeated for multiple services that call this utility method. Instead, it's better to test the utility method at one place, and then to mock it in all other services where it is called. Again, don't just use above to throw everything into a utils class and test it separately

- Controller + DTO + Service + related DB calls -- is best tested as a functional tests, by spinning up a local test server and making calls against it. This will allow you to rearrange code without having your tests go obsolete. This also means that if you rearrange code into or out of utils class, then tests may need to be updated. ALSO.. as said above, a util method starts its life as a private method, and turns into a util when called at multiple places. Does this mean that behaviors that were initially tested as part of service now needs to be moved a test of util.  If you choose to do so - then Yes, else just drop a comment in test file for util identifying the service that's doing a full test. The benefit of latter is that if the reuse of code as util goes off, then your tests are still intact.

- Despite all above being said, if you feel that a method is complex enough that covering all the branches will take substantial time, and if it cannot be easily made into service level test, and if doing so will cause a whole lot of repetition, and you have discussed it with others.. then make a separate test only to cover that method


Code arrangement:
- Entity classes have parent, child hierarchy/graph between different entities. However, service method can call different entities in a single go. The question comes whether the "util" class should have a hierarchy. The answer: yes. A util class corresponding to a child entity should be able to access all parent entity, and methods in parent-util class.. but it should not use methods in grandchild-entity or grandchild-util class. Why? because the goal of util is to capture slightly more complex processing that what goes in entity, but less complex than what goes in service - which has access to entire domain model. So, with util, you want to still respect hierarchy of  domain models to prevent running in circular dependencies.
--|---- The biggest confusion there will be is when 2 domains join. Let's say you have "People who can teach" and "School" domains. Here "teacher" forms when "people who can teach" are employed by "school" and so, it lies in the intersection of the 2 domain, meaning, anytime you talk of "teacher", it implies there are both related "people" and "school" information. But what about "gauging how good of a teacher a person can be" - this depends on school's requirements, and on person's capability, so the 2 domains are present, but there need not be relation between the 2 yet. So, you can "test person's capability to teach for school before they are employed", or "test person's capability to teach for school after they have already been employed" (think of like, quarterly evaluation, or checking for bonus, etc). So, in this case, even though there are just 3 entities (person, school, teacher-join-table), there can be a total of 4 util classes: person-util, school-util, match-util(accepts person, school in argument, but never explicitly tests whether a relation between the 2 exists), and teacher-util (accepts only teacher, and from it, can either use only person, or school, or both information)

- Let's say you have a service with a logic specific only to the service. For some other requirement, you need to add a postprocessing which is similar to as-if calling the service. One option could be to refactor the service logic as a public util method, and reuse it in the service, and also in postprocessing. Other option could be leave the service logic there, and have the postprocessing logic make a REST API call to service endpoint, passing it the data, and waiting for a response from it. Which one to use?
--|---- This comes down to what is your team comfortable with -- because both of the options will work. My personal choice is the latter one for 2 main reasons: (1) Now you can decouple the postprocessing into a small code that can be triggered in cloud based on message received from main code. This is a more "loose coupled" design, and is more indicative of how a workflow would have happened if done manually, i.e. some user would have gotten data, and then they would have made some rest call. Here, same happens, but is done by code. (2) If you make a REST call, you have access to entire business domain objects. However, if you refactor method to a util, you must make sure that the hierarchy of objects is maintained, else this can get messy in future. For example: consider if your domain has entity of directory and file. And the need is that when a directory is made, then via an async post-processing, the directory name is capitalized and an "index" file is auto added to it. Since, the need is to do it async, the request object is no longer there. If you expose a service to capitalize directory name and add a file, then, being a service, it has access to Directory and File entity, and can easily do the task. However, if you would like to make it as a util, the the method to capitalize directory name can be in directory-util, but what about adding file? File entity is child to directory entity and so creating file should be in file-util and NOT in directory util. So your post processing is best defined as a util method in file-util, which uses another method in directory-util to capitalize the filename. **Much more trickier code arrangement that just calling an API
--|---- A few more things to consider: With the latter one of making a REST call, you can reuse the request logging that comes with someone making request, while refactoring as util would require you to add your own log. That's not a big deal though. The only big difference - that I feel - is that with the option of moving code to util.. the coupling between service and util layer just got a bit more tight! Maybe another reason is that if you move code to util, then you may want to refactor tests, which is some extra work! - this could be postponed, or called off by istead adding a comment.. so again, nothing big, but there are some advantages to making REST call.

- The only other methods that I feel can be added to a entity (other than getter/setter for entity fields) are ones that (1) return value based only on 1 or more entity field, (2) return value based on 1 or more fields, and on environment, (3) return value by following the parent entity using foreign key, and then using one of their "methods" (not fields), along with 1 or more entity field, and environment variable. In either case, do NOT allow (i) new setters, or methods that in any way mutate any entity. For mutation, best move that to a service utility, or DB utility method... and in any case, don't add that in model. (ii) Even for getter, if the logic starts getting complex, like, get something from one parent, then get something from other, etc.. you may want to move it as DB util because they are now becoming some kind of workflow than a simple lookup. (iii) Anything that calls/uses children entities



UI: CSR (client side rendering) vs SSR (server side rendering)
The main difference is that for SSR your server’s response to the browser is the HTML of your page that is ready to be rendered, while for CSR the browser gets a pretty empty document with links to your javascript. That means your browser will start rendering the HTML from your server without having to wait for all the JavaScript to be downloaded and executed. In both cases, React will need to be downloaded and go through the same process of building a virtual dom and attaching events to make the page interactive — but for SSR, the user can start viewing the page while all of that is happening
- SSR is hard requirement for SEO: SSR’ing pages allows crawlers (googlebot, etc) to effectively scrape pages so they can be indexed, and made available. 
- SSR & Performance: SSR also provides for better performance -- because HTML is initially rendered on page load, users do not need to wait until static assets are downloaded before they can view, and scroll through the contents. 

-- So, SSR may add somewhat of a pressure on server, but it can help with rendering performance.



IMPORTANT: Let's say you have a microservice/service with a corresponding DB. Now, for some reason, you need to copy over some data fields from this DB into a separate DB to be used by other service. At this time, you must ask: What's the source of truth information? Will it be original DB, or the new DB? The problem is that if a field is modified in any DB, then the data in 2 data gets out of sync. Then whose responsibility is it to sync that data between two; Is child DB system even allowed to update data in parent DB system; How long of a time gap is allowed where data can remain out of sync (..essentially, when you copy data, you form a distributed DB, and so you run into CAP based restrictions)
--|---- If there are fields in table in original DB that do not change with time and are fixed for each user (like id, or a system generated code assigned to each user that doesn't change with time), then such fields can be easily copied over. These will remain invariant for each user and over all time.
--|---- If the contract between the parent and child service is such that the child just copies parent data at one time, and then all services based on child DB uses that data.. then, sure, data can be copied from parent to child DB.. because the services based on child DB work with the understanding that data can modify over time in parent DB, but that they don't care about it
