Python + JS Notes:





Python NOTES:

If you have structure of : /root, /root/a (with __init__.py, a_1.py), /root/b (with __init__.py, b_1.py) : and want to import something from "a" inside "b".. then you cannot do it since python traverses up and down only in "module". Since "root" does not have a "__init__.py", so, it is not a module and that prevents using .. for traversal one level up. Thus, sometimes, you see an __init__.py file at root level which is empty.. it is mainly to make it a module. SO.. why is it needed? - because organizationally, it makes anything from within a module as being able to relate with each other. Thus, with top level __init__.py present, it means that /root/a and /root/b and /root : all belongs to same "app" and can be traversed.. but without the __init__.py within /root, it means that /root is having 2 independent apps of /root/a, and /root/b - that should ideally not be interacting with each other (unless /root/b declares /root/a as a dependency) -- See https://stackoverflow.com/questions/36301772/django-how-to-use-models-from-another-app
Since having __init__.py makes a folder as a module, you can do something like: /root, /root/foo.py, /root/foo/__init__.py. This is valid in that it gets made -- but not sure how Python interpreter would handle it.. because when doing "from root.foo import ...", it is not clear whether foo.py needs to be looked, or /foo/__init__.py needs to be looked.. or what is the precedence / collision resolution, or merging strategy. SO.. DO NOT DO SO!!
NOTE: Unlike JS, Python has import controls but no "export" command. Anything made in the file is importable! So, if you want it as private, using an underscore as prefix in name becomes much more important.
Above point mentions how everything in a python file is exportable. Taking it further, if you do any "imports" in a file.. even those get exportable if someone does an "import *" to your file.
With above.. consider if an __init__.py is made, within which the import calls are done. Now, those "imports" are available within __init__.py scope; and if anyone imports this __init__.py file, they'll also end up importing the imports done in __init__.py. This brings to usability of having __init__.py. Presence of this file declares a module. When someone from outside is importing functions from a module, the idea is to let them have those functions without worrying about the internal structure of the module. So, if someone does "from foo import Bar"; then they shouldn't have to worry about how "Bar" is situated within "foo" module -- that is internal to "foo". This is where having an __init__.py file is helpful. Now, you can just change the import statement in __init__.py depending on internal structure.. and anyone importing out from "foo" module will keep on getting the imported function without worrying about how it is situated in module itself.
See https://stackoverflow.com/questions/44834/can-someone-explain-all-in-python -- In general, doing "import *" is a bad code practice because you are polluting namespace, not sure whether you are getting something or not, and not creating relation between how something is getting used in code. STILL.. it is a possibility to happen.. and so it's a good practice that within __init__.py, also add __all__ listing the exports that get made when "import *" is called








JS NOTES:

Since having index.js makes a folder as a module, you can do something like: /root, /root/foo.js, /root/foo/index.js. This is valid in that it gets made -- but not sure how JS interpreter would handle it.. because when doing "import ... from root.foo", it is not clear whether foo.js needs to be looked, or /foo/index.js needs to be looked.. or what is the precedence / collision resolution, or merging strategy. SO.. DO NOT DO SO!!
What is the importance of module --> See notes in Python - regarding module - which discuss same thing
Making json with dynamic field name: let a="abcd"; let b = {[a]: a}; <-- this will make b = {abcd:"abcd"}. You can also do: b={[a+'ef']:a}; <-- this will make b = {abcdef: "abcd"}. However, also be careful because you can also do: b={[a+'e:"xyz",ab']:a} <-- b = {abcde:"xyz", ab:"abcd"}. So, best use this only for constants!!!








EXTRA NOTES:

In own notes.. you've mentioned that order of precedence for classes go as: ChildDTO >> ParentDTO (because parentDTO json may be asked to show child DTO json as a list); but ParentEntity >> ChildEntity (because ChildEntity needs to have a foreign key to parentEntity). This is a reason why DTO and Entity should not be one single class - because this cannot be done side by side to also achieving above behavior. 
HOWEVER.. one can question that if DTOs are supposed to be like "contracts" telling customers what to expect.. then shouldn't it also be that parentDTO (top level contract) is hashed out before childDTO (lower level contract); So shouldn't patentDTO be >> childDTO rather than other way round. That's true - except last part of logic - when childDTO is hashed out, it should be seen as a "fine grain" contract specification.. and so its effect bubbles up and effects high level contract spec, which is "parentDTO". So, even though parentDTO is hashed out at earlier times than childDTO.. any time there is childDTO change, the effect bubbles up all the way to parentDTO, and that's why childDTO gets higher precedence. THIS IS ANOTHER REASON, why Entity classes shouldn't be used for DTO
As a rebuttal, one can think of an exception here. Let's say when making childEntity to childDTO, it is decided to never serialize a parentEntity within childEntity; and also forego the ability to show list-of-child within parentDTO.. but instead provide a HATEOAS link to get all children DTO individually.. would that work? NO!! Once again, the question is how will a parent know what all child-links are available to it.. and it needs to be dynamic. What has happened in this solution is sort of a "Laziness" where instead of actively returning back the child data, links are returned that can be queried for the data. There is no reduction in scope of contract-data that parentDTO provides, but it has been "lazied" out. As mentioned in own notes, you can do it by creating custom header tags that control whether child data would be populated or not. This does bring up a better design, where instead of giving out data, parentDTO instead gives out links to get child data!!
Take this argument one extra level.. when we have a many-to-many table. In that case, the precedence should be: Table1Entity ~ Table2Entity >> ManyToManyTableEntity. So, by logic, one would get: ManyToManyTableDTO >> Table1DTO ~ Table2DTO. In terms of "contract" spec, it can be understood that Table1 spec and Table2 spec could be defined at whatever time.. but ManyToManyTable must be spec'd out after Table1 and Table2 have been spec'd out. 
Building from above, this means that Table1DTO and Table2DTO should both contain ManyToManyTableDTO list entries (each ManyToManyTableDTO value showing only the id field for ManyToManyTable entity). The drawback - when looking at DTO for, say, {Table1Id}, it will show only the Id for multiple {ManyToManyTable} rows related to it - but that's not of much use because it does not say what all Table2 entries are actually related to Table1. If the Table1DTO is modified to show list of Table2DTO associated to it via ManyToManyTable, and same done for Table2, then it creates a circular dependency where it is not clear whether Table1 came first or Table2 - both end up depending on the other! Also, if Table1DTO shows list of Table2DTO related to it, it gives a wrong indication that Table2 is child of Table1 - which it is not!!! Another wrong thing that happens by listing Table2 under Table1 is that it gives indication as if deletion of single Table1 entry will delete all nested Table2 entries under it - which it will not. So, for many reasons, this is not a good design to pursue.
Doing a deep-dive, in this diamond structure, we notice: (a) Table1 is child of, say, some grandparent (or just '/' root), (b) Table2 is child of same grandparent, (c) ManyToManyTable is a child of {Table1 X Table2} product, which is a child of same grandparent. Since existence of the grandparent is the commonality, one could think of having 3 and not 2 url immediately under grandparent, like: grandP/{grandPId}/Table1/{Table1Id}; grandP/{grandPId}/Table2/{Table2Id}; grandP/{grandPId}/CrossProductResource/{CrossProductResourceId}. Here, the first 2 are proper REST structure, so, let's focus on the 3rd one. Here, the CrossProductResource is some imaginary resource (..for now) that is postulated to exist immediately below grandparent and not below Table1 or Table2 (..because CrossProduct contains extra information that cannot be hierarchically supported by Table1 and Table2 alone). The CrossProductResourceService class is defined to have dependency on ManyToManyTableService, Table1Service, Table2Service. When creating new ManyToMany record.. there is no ManyToManyTableController.. but there is a CrossProductResourceController which is called -- the reason being that CrossProductResourceService needs to have handle to Table1Repo, Table2Repo, ManyToManyTableRepo (..and also corresponding service class) to orchestrate the full request call. Also postulated.. that this service returns a new CrossProductResourceDTO - something without corresponding entity mapping - and this now lies at higher hierarchy than Table1 or Table2 alone, and returns the joint mapping between them, using data from ManyToManyTable. Thus, ManyToManyTable exists as an Entity without a direct-DTO, and, CrossProductResourceDTO exists as a DTO without a direct-Entity. Note that this also solves the dependency ordering. Now, CrossProductResourceService lie above Table1Service and Table2Service; And, CrossProductResourceDTO lie above Table1DTO and Table2DTO. In doing an endpoint call.. a query-param can be passed that filters either column(s)of manyToManyTable to find all matches corresponding to a particular Table1-foreignKey, or Table2-foreignKey, or both?!
NOTE that the above problem may seem slightly different from, say, having DB/row vs file representation of a resume. The latter problem relates to different representation of same data; so think about diamond pattern without the 4th table, i.e. the 2 child table have some sort of one-one relation between them, but for only a subset of cases, and not always. In this problem - for those apt cases, when updating one portion of data, the code should automatically update the other portion of data. So, for example, when updating DB fields for resume, the resume-file should get auto-updated, and vice versa. Note, that there is no separate URL to give the relation between DB-row-data and resume-file, nor, is it something that can change later. This one to one relation is fixed, and is either there (for resume type data), or not there (if filetype is other than resume). So, in this case, there is no explicit CrossProductResourceController that exposes an endpoint. Now, there is just Table1Service and Table2Service.. and as part of their logic, they call the CrossProductResourceService to ensure that other Table is in coherence when data is sent to one of the Table via corresponding endpoint. In this case, CrossProductResourceService is now below the Table1Service and Table2Service!!!!




1) In Hateoas links, apart from internationalization 
---- also give security detail : who all will be accessing the data. Is there any restriction on mutating data, etc. Maybe just give link to security policy
---- a question is if you can guide users into using your webpage/REST-url in suitable flow. Maybe each URL within each level can be numbered so that users are guided. For some who have already done part of work.. they can skip those portions and get to next step. Maybe give guidance on how a user can identify which step they should start with.. say by doing successive GET calls.

2) If a field/fields can take enumerated value only, then give all possible combination.. or url to get combination possibility, along with what they mean. This helps user understand enum values which are not in their language. Maybe give different enum-options based on the language selected by user?!! and/or add a translator at beginning so that the json data is translated to one understood by server.. even though it starts from one that is understood by server

3) add a language field in all Entity to identify the language used by user when making entries. 

