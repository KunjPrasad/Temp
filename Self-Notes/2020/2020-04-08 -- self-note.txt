DJANGO:
1) **VERY VERY IMPORTANT**: Say, you have Resource1. Resource2 uses Resource1, Resource2, and have many-to-one relation (Similar layout is in https://medium.com/better-programming/django-select-related-and-prefetch-related-f23043fd635d). Now, the requirement comes to get Resource1, with conditions on Resource-1,3, and to also get corresponding Resource-2. 
--|---- VERY VERY VERY IMPORTANT: See the article. It has a decorator which is able to capture time, and also capture count of queries made!! Possibly by exploring involved module "from django.db import connection, reset_queries" - more utilities can be identified for db performance identification.
--|---- select_related:: We use select_related when the object that you're going to select is a single object, which means forward ForeignKey, OneToOne and backward OneToOne.
select_related works by creating an SQL join and including the fields of the related object in the SELECT statement. For this reason, select_related gets the related objects in the same database query.
--|---- prefetch_related:: We use prefetch_related when we’re going to get a set of things.
That means forward ManyToMany and backward ManyToMany, ForeignKey. prefetch_related does a separate lookup for each relationship, and performs the “joining” in Python. Particularly realize that: 
--|----|---- It is different from select_related, the prefetch_related made the JOIN using Python rather than in the database.
--|----|---- prefetch_related 'prefetches' the collection-type data corresponding to 1 entry of main query, and doing so for collection of 'main-query-entries' ..and uses python for joining it. ALSO - the query it uses to prefetch-data is fixed, either all related, or based on query given in 'Prefetch' operator. If that query changes later, then Django will refetch, so make sure the query does not change later.
--|---- Coming back.. **IMPORTANT** realize that there are 2 ways to solve above problem: (i) Use Resource1.objects manager and invoke 'prefetch_related', or, (ii) Use Resource3.objects manager and just do select_related.
--|----|---- **IMPORTANT**: realize that regardless of option chosen, the mapped url for RESt resource will still be /Resource1/{id} - because at end of day, it is still the Resource1 which is being fetched back.
--|----|---- The drawback of using 2nd option, i.e. starting with Resource3.objects manager and then going back.. is that at end you have started with a Resource3 manager. While the 'get' calls can be made to work by possibly changing serializers - and using 'source'.. this creates problem when modifying calls like put, post, delete is made. In this case, you'd want to delete resource1 object.. but won't be able to do so since you started your queryset with Resource2's manager. THUS.. AVOID DOING SO.

2) **IMPORTANT** - Good design: When designing your rest calls, for getting single item information, a good consideration is to ensure that:
(i) [WEAK] it returns only the information of object is question - and no more. If you want information about related-objects, then that should be another call. However, this is a weak consideration and can be overturned as necessary.
(ii) [STRONG] At any point, if you're returning a list that is unbounded, either as sub-field when doing a GET one object call, or if making a list call - that is not a good design. A good design always filters in some way or other to prevent sending unbounded list. Speaking generally, returning unbounded list at any point just tells that the design isn't hashed out on what to do once the list is obtained.

3) In earlier notes.. it is said to keep any logic inside a View / ViewSet as much declarative as possible. Any imperative logic should be properly moved in serializer, model or last.. in util. There is one more place where imperative logic can be moved -- in Mixins that are used with View. Also, recall that certain logic can be put in context_processor, or in middleware

4) **IMPORTANT** What's the best way to handle referential-check failure in DB?
--|---- FIRST.. realize that if you are in scenario where you are thinking of "referential checks", it means you are wanting to walk down a URL path and/or headers to go to some resource. If DB is denormalized, this entails doing multiple joins. Another solution could be to denormalize your table to prevent joins. **REALIZE** that whatever solution you come to regarding handling of referential -check failure should be equally applicable to BOTH designs - because you're answering on how to handle referential-checks failure.. not on how to handle if implementation is a particular manner or other!
--|---- If you have NOT De-normalized design, then going to the final element being queried for requires traversing down the join path. So, unless you are at the table in question, and have gotten yourself down to finding no matching entries - that is a referential check failure.**NEXT ARE IMPORTANT POINTS**: 
--|----|---- Note that the traversal down the join-path is something that'll happen in a method of View class, which means that this must be DECLARATIVE in nature. 
--|----|---- The imperative code for the methods used in View must be in defined in mixin, or in some utils, which are now available to every other View using that mixin/util.
--|----|---- Since the mixin/util logic is common code, it is expected that this code should NOT have any special behavior to raise exception depending on whether the table being queried for is final table or non-final table. -- Doing so is breaking Single Responsibility in SOLID. Thus, the likely choice is for this table to return 404 if going down the chain, any entry is not found. It now comes to View to catch and rethrow the exception if it hasn't touched final table and a NotFound is thrown (..and, of course, if that is the expectation).
--|----|---- Above can be seen as likely correct logic -- because even when working with denormalized table, one gets similar behavior. Here, instead of multiple joins, one instead has a WHERE clause consisting of different arguments. Failure in referential check causes "nothing" to be returned, which becomes 404. The difference between this and previous case is that one can no longer tell if 404 is because of referential failure or there is actually no such final object entry. THIS ALSO TELLS.. that a better design is to always return 404, even if you have a referential check failure because (i) you get architectural flexibility, (ii) If a resource is not found, it is not found.. why do you need bend over backwards and divulge information to user that it's because of referential failure. Plus, a user that does referential failure is most likely an attacker -s o don't do it -- [[Same logic also goes in why you should always return 200 for delete, even if entry does not exist -- plus, it gives idempotence to correct user]]
--|---- While above corresponds nicely for GET calls, what about POST / PUT calls? 
--|----|---- First of all.. realize that even if you've done checks before making final save() call in View, it is still good to have referential checks at DB level. This is because referential checks at DB level are indicative of constraints that you would have preferred adding in sql when making tables.. but that they are complex enough to do so there. So, have them regardless
--|----|---- Say, you're in POST call, and NOT have DE-normalized table, are going down the chain before making final save(). Since you're in view, you'll end up using same mixin/utils made that returned 404 for referential failures. So, just like GET call, if you want to return 403, etc., you'll need to once again catch and rethrow a new error.
--|----|---- Now, consider you're in a DENORMALIZED table. In this case, you cannot do referential checks because no such concept exists at View level. Anything is allowed.. and it is now the DB that does the referential checks and rejects adding new entry if the checks fail. This shows the need to have referential check directly on DB's save method regardless of what's happening at View level.
--|----|---- For denormalized case, even if you choose that you'd want to call the mixin/util logic to identify early on if there is a potential referential failure.. note that doing so will require invoking same utils that return 404. So, once again, for all cases - when making POST call - you still end up with 404 when there are referential failures. If, however, you want to raise a different error, then that requires adding new logic in View to catch the 404 and re-raise it as a different one.
--|----|---- ONE THING VERY CONFUSING ABOUT in case of POST calls.. is that "POST" means "create a resource", and it uses same url as a "list view". So, if it returns 404, that means an "object is not found" ..but we weren't trying to find something, but were trying to make something. This can become an impetus to raise 400 ValidationError instead of 404 NotFound on referential check failure. The long list of above logic is to provide rationale on why a 404 should be raised on referential check failure rather than 400 (..unless, of course, you want to catch 404 and turn it to 400). returning 404 on POST can be interpreted as "the resource which is to create this object with broken referential checks" is not available. 
--|----|----|---- PERSONALLY, I SUGGEST.. If you want to catch and rethrow as 400, that is ok.. just do so early in View logic, ..rather than continuing to pull objects from DB without doing any checks, and sending them off to DB and expecting DB to do referential check and then throwing as 400. POINT IS: If you can do a check early on and verify, you must do so. So, exceptions are when this is not possible, for example, doing a uniqueness check!
--|----|----|----|---- **VERY VERY VERY IMPORTANT**: Doing validation first as soon as possible is the way to go! If you don't do this, there is one use case that badly hurts which is if you do get the referentially-invalid data, then use it in some manner (say for stats calculation), and use the result. This will apparently show that you haven't broken any rules - but you would have. Similar bad-patterns can allow bypassing data-authorization control.. in name of getting a "reduced" information out of it



DB-DESIGN:
1) **VERY VERY IMPORTANT**: Consider you're making an object (obj1) and that requires also making a "list" of other objects (ob2). In such cases, ALWAYS start by considering whether the list of other objects (obj2(s)) should be encapsulated and made into a new object (obj3) and then obj3 be linked to obj1. OR, if it's ok to have list-of-obj2 directly get attached to obj1. 
As mentioned in above note, at any point if you are returning an unbounded list as part of REST call (either because a list type GET call was made, or if a single object GEt call was made but it had a list type within it) -- that rather signifies an incomplete architecture discussion or not knowing what to do with results. A natural way to improve that is to include searching, sorting -- and a next level way to improve it is to add sub-grouping in the list. Thus, unless a list is fixed after it's made.. it can get big and it can benefit from sub-grouping in some form. Alternatively, if an object-collection is finite but can go through evolution stages, then then the stage itself becomes a cluster information. In both these cases, it benefits to have an object that encapsulates the list, and then have that object get referenced. Note that having an encapsulate object also allows for "list-versioning" that can now be allowed to evolve without losing handle to past changes.